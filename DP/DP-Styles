---Sub(set-sequence) DP(take or leave):
If we have an array: [1 7 2 5 3 9] the anser may be 7 5 3
                     [0 1 0 1 1 0]
-Problems like knapsack or LCS or LIS can be solved using this style. 
-In LIS the function parameters are (Cur_idx,prev), prev may be a number or index. if the array contains
negative or very big values prev should be an index. If the numbers in array are very big we should use prev as a number.
-In LCS we make take or leave but on 2 strings at the same time. abdc       abc
                                                                 1101       111
so we have 4 choices: 
1-Take Take: when the crosponding characters are the same. 1+dp(i+1,j+1)
if the crosponding characters aren't the same:
2-Take leave: dp(i,j+1)
3-leave Take: dp(i+1,j)
4-leave leave: dp(i+1,j+1) and the difference between it and take take is that we won't add when to the recursive call. We can ignore this case as when we call 
take leave or leave take in the next state of each one they will call leave leave.

-In coins(UVA 147), we can take more than one. 5 10 20 50 100 200 500 1000 2000 5000 10000 
                                               2 4  0  0  0    0   0   0    0    0     0
so we will make a loop to take more than one. We can reduce the complexity of the loop by pushing it to a parameter(we use it when there's a loop in a recursive code
which changing the value of one parameter).

example:
portion of the old code:

int cnt=dp(idx+1,rem),temp=rem;
    while(temp-coins[idx]>=0)
    {
        cnt+=dp(idx+1,temp-coins[idx]);
        temp-=coins[idx];
    }
    return memo[idx][rem]=cnt;

after pushing loop to a paremeter:

return memo[idx][rem]=dp(idx+1,rem)+dp(idx,rem-coins[idx]);

We reduce the complexity from O(idx*(max_coins)^2) to O(idx*max_coins).
