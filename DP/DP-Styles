---Sub(set-sequence) DP(take or leave):
If we have an array: [1 7 2 5 3 9] the anser may be 7 5 3
                     [0 1 0 1 1 0]
-Problems like knapsack or LCS or LIS can be solved using this style. 
-In LIS the function parameters are (Cur_idx,prev), prev may be a number or index. if the array contains
negative or very big values prev should be an index. If the numbers in array are very big we should use prev as a number.
-In LCS we make take or leave but on 2 strings at the same time. abdc       abc
                                                                 1101       111
so we have 4 choices: 
1-Take Take: when the crosponding characters are the same. 1+dp(i+1,j+1)
if the crosponding characters aren't the same:
2-Take leave: dp(i,j+1)
3-leave Take: dp(i+1,j)
4-leave leave: dp(i+1,j+1) and the difference between it and take take is that we won't add when to the recursive call. We can ignore this case as when we call 
take leave or leave take in the next state of each one they will call leave leave.

-In coins(UVA 147), we can take more than one. 5 10 20 50 100 200 500 1000 2000 5000 10000 
                                               2 4  0  0  0    0   0   0    0    0     0
so we will make a loop to take more than one. We can reduce the complexity of the loop by pushing it to a parameter(we use it when there's a loop in a recursive code
which changing the value of one parameter).

example:
portion of the old code:

int cnt=dp(idx+1,rem),temp=rem;
    while(temp-coins[idx]>=0)
    {
        cnt+=dp(idx+1,temp-coins[idx]);
        temp-=coins[idx];
    }
    return memo[idx][rem]=cnt;

after pushing loop to a paremeter:

return memo[idx][rem]=dp(idx+1,rem)+dp(idx,rem-coins[idx]);

We reduce the complexity from O(idx*(max_coins)^2) to O(idx*max_coins).


---Consecutive Ranges Style:
If we have an array of integers or characters and we want to divide it to set of groups according to a certain criteria.
For example abcdefgh the answer may be (abc)(d)(ef)(g)(h). The simple dp approach is to use 2 pointers for detirmining the start and the end for a certain interval
and at each end we decide to expand the interval(adding a new element to it) or to stop it and begin a new one according to the given criteria.
-Solutions to the pearl problem:
1-
int n,cnt[n],pr[n];
int memo[][];
int dp(int cur_idx,int last_idx)
{
    if(cur_idx==n)
        return 0;
    if(~memo[cur_idx][last_idx])
        return memo[cur_idx][last_idx];
    int sum=10;
    for(int i=cur_idx;i<=last_idx;i++)
        sum+=cnt[i];
    //Enough interval
    memo[cur_idx][last_idx]=dp(i+1,j+1)+sum*pr[cur_idx];
    // Add me to current interval
    if(cur_idx!=n-1)
        memo[cur_idx][last_idx]=min(memo[cur_idx][last_idx],dp(i+1,j));
    return memo[cur_idx][last_idx];
}
Time and space complexity of this solution are o(n^3),o(n^2). we can reduce the time complexity by using prefix sum o(1) instead of the loop ,so the complexity
will be o(n^2).

2-
We can carry the sum of the previous interval but will this increase the complexity? no the new prameter depends only on the cur_idx and last_idx and it's constant
for any combination of values for(cur_idx and last_idx) we name it inferenced variable. Is cur_weight in knapsack an inferenced? no for a certain idx its value
may be different because we take or leave elements before the current idx.

int n,cnt[n],pr[n];
int memo[][];
int dp(int cur_idx,int last_idx,int cur_sum=0)
{
    if(cur_idx==n)
        return (cur_idx==last_idx)?0:1e9;
    if(~memo[cur_idx][last_idx])
        return memo[cur_idx][last_idx];
    return memo[cur_idx][last_idx]=min(dp(cur_idx+1,cur_idx+1,0)+(cur_sum+cnt[cur_idx]+10)*pr[cur_idx],dp(cur_idx+1,last_idx,cur_sum+cnt[cur_idx]));
}
// Note that: previousSum is inferenced variable and equals SumRange(i, j). Then we don't memoize it.

3-
Pushing a parameter to loop, to decrease the space complexity. We will fix one pointer and make a loop to move the other one from the starting pointer until reaching 
the end (or certain value according to the criteria).
int n,cnt[n],pr[n];
int memo[];
int dp(int cur_idx)
{
    if(cur_idx==n)
        return 0;
    if(~memo[cur_idx][last_idx])
        return memo[cur_idx];
    int sum=0,mn=INT_MAX;
    for(int j=cur_idx;j<n;j++)
    {
        sum+=cnt[cur_idx];
        mn=min(mn,dp(j+1)+(10+sum)*pr[cur_idx]);
    }
    return memo[cur_idx]=mn;
}
Time and space complexity of this solution are o(n^2),o(n) efficient for memory.
